const express = require('express');
const crypto = require('crypto');
const { createClient } = require('@supabase/supabase-js');

const router = express.Router();

// ===============================================
// CONFIGURA√á√ÉO SUPABASE COM SERVICE ROLE KEY
// ===============================================
// Usar Service Role Key para bypassing RLS em webhooks
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

// ===============================================
// IMPORTAR PROCESSADOR DE IA
// ===============================================

let messageProcessor;
try {
  messageProcessor = require('../services/message-processor');
  console.log('‚úÖ Processador de IA carregado com sucesso');
} catch (error) {
  console.log('‚ùå ERRO ESPEC√çFICO:', error.message);
  console.log('‚ùå STACK:', error.stack);
  messageProcessor = null;
}

// ===============================================
// CONFIGURA√á√ÉO DO WHATSAPP
// ===============================================
const WEBHOOK_VERIFY_TOKEN = process.env.WHATSAPP_WEBHOOK_VERIFY_TOKEN || 'crm_webhook_token_2025';
const WHATSAPP_APP_SECRET = process.env.WHATSAPP_APP_SECRET || '';

// ===============================================
// CACHE DE USU√ÅRIO PADR√ÉO
// ===============================================
let defaultUserId = null;

// ===============================================
// GET: VERIFICA√á√ÉO DO WEBHOOK (CHALLENGE)
// ===============================================
router.get('/whatsapp', (req, res) => {
  console.log('üîî Verifica√ß√£o de webhook recebida');
  
  const mode = req.query['hub.mode'];
  const token = req.query['hub.verify_token'];
  const challenge = req.query['hub.challenge'];
  
  console.log('üìã Par√¢metros:', { mode, token, challenge });
  
  // Verificar se √© uma requisi√ß√£o de verifica√ß√£o v√°lida
  if (mode === 'subscribe' && token === 'crm_webhook_token_2025_secure') {
    console.log('‚úÖ Webhook verificado com sucesso!');
    res.status(200).send(challenge);
  } else {
    console.log('‚ùå Falha na verifica√ß√£o do webhook');
    res.status(403).send('Forbidden');
  }
});

// ===============================================
// POST: RECEBER MENSAGENS DO WHATSAPP
// ===============================================
router.post('/whatsapp', express.raw({ type: 'application/json' }), async (req, res) => {
  console.log('üì± WhatsApp Webhook - Mensagem recebida');
  
  try {
    // VALIDA√á√ÉO DE ASSINATURA DESABILITADA PARA TESTES LOCAIS
    // Em produ√ß√£o, descomente e configure WHATSAPP_APP_SECRET
    /*
    if (WHATSAPP_APP_SECRET) {
      const signature = req.get('X-Hub-Signature-256');
      const body = Buffer.isBuffer(req.body) ? req.body : Buffer.from(JSON.stringify(req.body));
      const expectedSignature = crypto
        .createHmac('sha256', WHATSAPP_APP_SECRET)
        .update(body)
        .digest('hex');
      
      if (!signature || signature !== `sha256=${expectedSignature}`) {
        console.log('‚ùå Assinatura inv√°lida');
        return res.status(401).send('Unauthorized');
      }
    }
    */
    
    // Parse do body
    let body;
    if (typeof req.body === 'string') {
      body = JSON.parse(req.body);
    } else if (Buffer.isBuffer(req.body)) {
      body = JSON.parse(req.body.toString());
    } else {
      body = req.body;
    }
    
    console.log('üìù Body recebido:', JSON.stringify(body, null, 2));
    
    // Verificar se √© uma mensagem v√°lida
    if (body.object !== 'whatsapp_business_account') {
      console.log('‚ùå Objeto inv√°lido:', body.object);
      return res.status(400).send('Bad Request');
    }
    
    // Processar cada entrada
    if (body.entry && body.entry.length > 0) {
      for (const entry of body.entry) {
        await processWhatsAppEntry(entry);
      }
    }
    
    // Responder rapidamente ao WhatsApp
    res.status(200).send('OK');
    
  } catch (error) {
    console.error('‚ùå Erro ao processar webhook:', error);
    res.status(500).send('Internal Server Error');
  }
});

// ===============================================
// FUN√á√ÉO: BUSCAR USU√ÅRIO PADR√ÉO DO SISTEMA
// ===============================================
async function getDefaultUserId() {
  if (defaultUserId) {
    return defaultUserId;
  }
  
  try {
    // Buscar primeiro usu√°rio ativo do sistema
    const { data: user, error } = await supabase
      .from('users')
      .select('id')
      .eq('status', 'active')
      .order('created_at', { ascending: true })
      .limit(1)
      .maybeSingle();
    
    if (error || !user) {
      console.log('‚ö†Ô∏è Nenhum usu√°rio ativo encontrado no sistema');
      return null;
    }
    
    defaultUserId = user.id;
    console.log('üë§ Usu√°rio padr√£o definido:', defaultUserId);
    return defaultUserId;
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar usu√°rio padr√£o:', error);
    return null;
  }
}

// ===============================================
// FUN√á√ÉO: PROCESSAR ENTRADA DO WEBHOOK
// ===============================================
async function processWhatsAppEntry(entry) {
  try {
    console.log('üîÑ Processando entrada:', entry.id);
    
    if (!entry.changes || entry.changes.length === 0) {
      console.log('‚ö†Ô∏è Sem mudan√ßas na entrada');
      return;
    }
    
    for (const change of entry.changes) {
      if (change.field === 'messages') {
        await processMessages(change.value);
      } else if (change.field === 'message_status') {
        await processMessageStatus(change.value);
      }
    }
    
  } catch (error) {
    console.error('‚ùå Erro ao processar entrada:', error);
  }
}

// ===============================================
// FUN√á√ÉO: PROCESSAR MENSAGENS
// ===============================================
async function processMessages(value) {
  try {
    console.log('üí¨ Processando mensagens');
    
    if (!value.messages || value.messages.length === 0) {
      console.log('‚ö†Ô∏è Sem mensagens para processar');
      return;
    }
    
    const phoneNumberId = value.metadata?.phone_number_id;
    const displayPhoneNumber = value.metadata?.display_phone_number;
    
    console.log('üìû Phone Number ID:', phoneNumberId);
    console.log('üì± Display Phone:', displayPhoneNumber);
    
    // Processar cada mensagem
    for (const message of value.messages) {
      await processSingleMessage(message, phoneNumberId);
    }
    
  } catch (error) {
    console.error('‚ùå Erro ao processar mensagens:', error);
  }
}

// ===============================================
// FUN√á√ÉO: PROCESSAR MENSAGEM INDIVIDUAL
// ===============================================
async function processSingleMessage(message, phoneNumberId) {
  try {
    console.log('üì® Processando mensagem:', message.id);
    
    const {
      id: whatsappMessageId,
      from: senderPhone,
      timestamp,
      type: messageType,
      text,
      image,
      audio,
      document,
      video
    } = message;
    
    // Extrair conte√∫do baseado no tipo
    let content = '';
    let metadata = { 
      whatsapp_phone_number_id: phoneNumberId,
      timestamp: parseInt(timestamp),
      raw_message: message 
    };
    
    switch (messageType) {
      case 'text':
        content = text?.body || '';
        break;
      case 'image':
        content = image?.caption || '[Imagem]';
        metadata.media = {
          id: image?.id,
          mime_type: image?.mime_type,
          sha256: image?.sha256
        };
        break;
      case 'audio':
        content = '[√Åudio]';
        metadata.media = {
          id: audio?.id,
          mime_type: audio?.mime_type,
          voice: audio?.voice || false
        };
        break;
      case 'document':
        content = document?.filename || '[Documento]';
        metadata.media = {
          id: document?.id,
          mime_type: document?.mime_type,
          filename: document?.filename
        };
        break;
      case 'video':
        content = video?.caption || '[V√≠deo]';
        metadata.media = {
          id: video?.id,
          mime_type: video?.mime_type
        };
        break;
      default:
        content = `[${messageType}]`;
    }
    
    console.log('üìù Conte√∫do extra√≠do:', content);
    console.log('üë§ Remetente:', senderPhone);
    
    // Buscar ou criar contato
    const contact = await findOrCreateContact(senderPhone, phoneNumberId);
    if (!contact) {
      console.log('‚ùå Erro ao buscar/criar contato');
      return;
    }
    
    // Buscar ou criar conversa
    const conversation = await findOrCreateConversation(contact);
    if (!conversation) {
      console.log('‚ùå Erro ao buscar/criar conversa');
      return;
    }
    
    // Verificar se mensagem j√° existe (evitar duplicatas)
    const { data: existingMessage } = await supabase
      .from('messages')
      .select('id')
      .eq('whatsapp_message_id', whatsappMessageId)
      .maybeSingle(); // Usar maybeSingle() em vez de single()
    
    if (existingMessage) {
      console.log('‚ö†Ô∏è Mensagem j√° processada:', whatsappMessageId);
      return;
    }
    
    // Salvar mensagem no banco
    const { data: savedMessage, error } = await supabase
      .from('messages')
      .insert({
        conversation_id: conversation.id,
        content,
        message_type: messageType,
        sender_type: 'contact',
        whatsapp_message_id: whatsappMessageId,
        metadata,
        created_at: new Date(parseInt(timestamp) * 1000).toISOString()
      })
      .select()
      .single();
    
    if (error) {
      console.error('‚ùå Erro ao salvar mensagem:', error);
      return;
    }
    
    console.log('‚úÖ Mensagem salva:', savedMessage.id);
    
    // ===============================================
    // ü§ñ PROCESSAMENTO DE IA - NOVO!
    // ===============================================
    // Processar mensagem com IA (ass√≠ncrono para n√£o travar webhook)
    if (messageProcessor && savedMessage.id) {
      // Usar setImmediate para processar ap√≥s responder ao WhatsApp
      setImmediate(async () => {
        try {
          console.log('ü§ñ Iniciando processamento IA para mensagem:', savedMessage.id);
          const processingResult = await messageProcessor.processMessage(savedMessage.id);
          
          if (processingResult && processingResult.success) {
            console.log('‚úÖ Processamento IA conclu√≠do com sucesso');
            console.log(`üéØ Inten√ß√£o detectada: ${processingResult.intention}`);
            console.log(`üí¨ Resposta gerada: ${processingResult.response?.substring(0, 100)}...`);
          } else {
            console.log('‚ö†Ô∏è Processamento IA finalizado com erro ou sem resultado');
          }
        } catch (error) {
          console.error('‚ùå Erro no processamento IA:', error.message);
          // N√£o falhar o webhook por erro de IA
        }
      });
    } else {
      console.log('ü§ñ [FUTURO] Processamento IA n√£o dispon√≠vel - executando sem IA');
    }
    
    // ===============================================
    // ATUALIZAR CONVERSA
    // ===============================================
    // Atualizar √∫ltima intera√ß√£o da conversa
    const { error: updateError } = await supabase
      .from('conversations')
      .update({
        last_message: content.substring(0, 100),
        last_message_at: new Date().toISOString(),
        last_sender: 'contact',
        total_messages: (conversation.total_messages || 0) + 1,
        updated_at: new Date().toISOString()
      })
      .eq('id', conversation.id);
    
    if (updateError) {
      console.error('‚ùå Erro ao atualizar conversa:', updateError);
    } else {
      console.log('‚úÖ Conversa atualizada com sucesso');
    }
    
  } catch (error) {
    console.error('‚ùå Erro ao processar mensagem individual:', error);
  }
}

// ===============================================
// FUN√á√ÉO: BUSCAR OU CRIAR CONTATO
// ===============================================
async function findOrCreateContact(phone, phoneNumberId) {
  try {
    // Limpar n√∫mero de telefone
    const cleanPhone = phone.replace(/\D/g, '');
    
    // Buscar contato existente
    const { data: existingContact } = await supabase
      .from('contacts')
      .select('*')
      .eq('phone', cleanPhone)
      .maybeSingle(); // Usar maybeSingle() para n√£o dar erro se n√£o encontrar
    
    if (existingContact) {
      console.log('üë§ Contato encontrado:', existingContact.id);
      return existingContact;
    }
    
    // Buscar usu√°rio padr√£o do sistema
    const systemUserId = await getDefaultUserId();
    if (!systemUserId) {
      console.log('‚ùå Nenhum usu√°rio ativo no sistema para associar contato');
      return null;
    }
    
    // Criar novo contato associado ao usu√°rio padr√£o
    const { data: newContact, error } = await supabase
      .from('contacts')
      .insert({
        phone: cleanPhone,
        name: `Contato ${cleanPhone}`,
        lifecycle_stage: 'lead',
        user_id: systemUserId, // ‚úÖ CORRIGIDO: Usar usu√°rio v√°lido
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();
    
    if (error) {
      console.error('‚ùå Erro ao criar contato:', error);
      return null;
    }
    
    console.log('‚úÖ Novo contato criado:', newContact.id, 'para usu√°rio:', systemUserId);
    return newContact;
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar/criar contato:', error);
    return null;
  }
}

// ===============================================
// FUN√á√ÉO: BUSCAR OU CRIAR CONVERSA
// ===============================================
async function findOrCreateConversation(contact) {
  try {
    // Buscar conversa ativa existente
    const { data: existingConversation } = await supabase
      .from('conversations')
      .select('*')
      .eq('contact_id', contact.id)
      .eq('status', 'open')
      .maybeSingle(); // Usar maybeSingle() para n√£o dar erro se n√£o encontrar
    
    if (existingConversation) {
      console.log('üí¨ Conversa encontrada:', existingConversation.id);
      return existingConversation;
    }
    
    // Verificar se o contato tem user_id v√°lido
    if (!contact.user_id) {
      console.log('‚ùå Contato sem user_id v√°lido:', contact.id);
      return null;
    }
    
    // Criar nova conversa
    const { data: newConversation, error } = await supabase
      .from('conversations')
      .insert({
        contact_id: contact.id,
        user_id: contact.user_id, // ‚úÖ CORRIGIDO: Agora contact.user_id √© v√°lido
        status: 'open',
        ai_enabled: true,
        priority: 'normal',
        total_messages: 0,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .select()
      .single();
    
    if (error) {
      console.error('‚ùå Erro ao criar conversa:', error);
      return null;
    }
    
    console.log('‚úÖ Nova conversa criada:', newConversation.id, 'para usu√°rio:', contact.user_id);
    return newConversation;
    
  } catch (error) {
    console.error('‚ùå Erro ao buscar/criar conversa:', error);
    return null;
  }
}

// ===============================================
// FUN√á√ÉO: PROCESSAR STATUS DE MENSAGENS
// ===============================================
async function processMessageStatus(value) {
  try {
    console.log('üìä Processando status de mensagens');
    
    if (!value.statuses || value.statuses.length === 0) {
      return;
    }
    
    for (const status of value.statuses) {
      const { id: whatsappMessageId, status: messageStatus, timestamp } = status;
      
      // Buscar mensagem existente
      const { data: message } = await supabase
        .from('messages')
        .select('metadata')
        .eq('whatsapp_message_id', whatsappMessageId)
        .maybeSingle();
      
      if (message) {
        // Atualizar metadata com status
        const updatedMetadata = {
          ...message.metadata,
          status: messageStatus,
          status_timestamp: timestamp
        };
        
        const { error } = await supabase
          .from('messages')
          .update({ metadata: updatedMetadata })
          .eq('whatsapp_message_id', whatsappMessageId);
        
        if (error) {
          console.error('‚ùå Erro ao atualizar status:', error);
        } else {
          console.log(`‚úÖ Status atualizado: ${whatsappMessageId} ‚Üí ${messageStatus}`);
        }
      }
    }
    
  } catch (error) {
    console.error('‚ùå Erro ao processar status:', error);
  }
}

module.exports = router;